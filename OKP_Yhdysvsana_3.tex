\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{COBOL ja Python: Tyypitys ja laskennan kapselointi}
\author{Erkki Heino, Tero Huomo, Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{Tyyppijärjestelmät}

\subsection{COBOL}

Kielen eri toteutuksille yhtenäisten perustyyppien lisäksi COBOLin kääntäjien toteuttajat ja levittäjät tarjoavat usein lisää valmiita perustyyppejä \cite{wikipediacobol}. Suurin osa tarjoaa esimerkiksi osoittimet ja bittikentät (bit field).

\subsubsection{Tyypitys}

COBOLin tyypityksestä on ristiriitaisia käsityksiä. Wikipedian \cite{wikipediacobol} mukaan COBOL on vahvasti ja staattisesti tyypitetty kieli. Michael Coughlanin COBOL Tutorial \cite{cobolintro} kuitenkin väittää, ettei kääntäjä tee tyyppitarkistuksia, ja COBOL olisi heikosti tyypitetty. Coughlanin mukaan esimerkiksi ei-numeerinen arvo on mahdollista sijoittaa numeerista tietoa sisältävään muuttujaan. Kun väärää tietotyyppiä sisältävällä muuttujalla yritetään tehdä laskutoimituksia, COBOL-ohjelma kaatuu suorituksenaikaiseen virheeseen. 

Vuonna 2002 julkaistu Object Oriented COBOL sisältää sekä vahvan että heikon tyypityksen piirteitä \cite{objectorientedcobol}.

\subsection{Python}

\subsubsection{Alkeis- ja perustyypit}

Pythonissa ei ole erikseen alkeistyyppejä, vaan Pythonissa kaikki on ilmaistu olioina tai olioiden välisinä suhteina \cite{python2ref}. Jokaisella oliolla on \textit{identiteetti} (identity), tyyppi ja arvo. Identiteetti on olion luonnin jälkeen muuttumaton. Identiteettiä voidaan ajatella olion osoitteena muistissa. Myös olion tyyppi on muuttumaton. Tietyissä kontrolloiduissa tilanteissa tyyppiä on mahdollista muuttaa, mutta usein tyyppimuunnoksilla voi olla odottamattomia seurauksia.

Kun kaikki on ilmaistu olioina, Pythonissa myös esimerkiksi None on olio. None on vastaavuus Java-kielen null-arvolle. Toisin kuin Pythonin None, Javan null ei kuitenkaan ole olio, eikä sillä ole tyyppiä.

Kielessä on valmiina useita kymmeniä sisäänrakennettuja tyyppejä, jotka on lueteltu Pythonin tyyppihierarkiassa \cite{python2ref}. Valmiita numeerisia tyyppejä ovat esimerkiksi totuusarvot, kompleksiluvut, kokonaisluvut ja reaaliluvut. Pythonin versiossa 2 kokonaislukuja kuvaavat kiinteän mittainen \verb+int+ ja rajattoman pituisen kokonaisluvun mahdollistava \verb+long+. Pythonin versiossa 3 ei enää ole kiinteän pituisia kokonaislukuja lainkaan, vaan ainoastaan \verb+long+ \cite{python3ref}. Reaalilukujen ja kompleksilukujen arvoalueet voivat riippua käytettävästä konearkkitehtuurista, virtuaalimuistin määrästä sekä kääntäjän asetuksista. Pythonissa ei ole valmiina olemassa erillistä character-tyyppiä, vaan yksittäiset merkit ovat merkkijonoja. Erilaiset laajennusmoduulit lisäävät tyyppejä Javan kirjastojen tapaan.

\subsubsection{Tyypitys}

Python on vahvasti tyypitetty kieli \cite{staticvsdynamic}. Tietyn tyyppiselle muuttujalle ei voida tehdä toisen tyypin operaatioita ennen eksplisiittistä tyyppimuunnosta.

\begin{samepage}
\begin{verbatim}
a = 5
b = "9"
c = a + int(b)
\end{verbatim}
\end{samepage}

Esimerkissä \verb+b+ sisältää merkkijonon "9", mutta yhteenlaskussa merkkijonosta jäsennetään kokonaisluku. Jos kokonaislukujäsennyksen jättää tekemättä, antaa ohjelma kyseisellä rivillä poikkeuksen. 

Suoritusaikana muuttujan tyyppi ei ole sidottu, vaan muuttujaan voi dynaamisesti sitoa eri vaiheessa eri tyyppisiä olioita. Seuraavassa esimerkissä muuttuja \verb+a+ saa ensin kokonaislukuarvon 5. Sen jälkeen muuttujan \verb+a+ arvoksi muutetaan merkkijono "Hei".

\begin{samepage}
\begin{verbatim}
a = 5
a = "Hei"
\end{verbatim}
\end{samepage}

Pythonissa käytetään lisäki \textit{duck typing} -ohjelmointiparadigmaa \cite{ducktyping}. Olioiden tyyppiä tärkeämpää ovat niiden toteuttamat ominaisuudet ja metodit. Käytännössä tämä tarkoittaa sitä, että funktioiden parametreina annettujen olioiden tyyppiä ei tarkisteta suoritettavassa funktiossa. Jos parametrina ollut olio ei toteuta funktion parametrilta kutsuttavia metodeja, funktio signaloi suorituksenaikaisen virhetilanteen.

\begin{samepage}
\begin{verbatim}
class Ankka:
    def vaaku(self):
        print("Vaaaak!")
    def ui(self):
        print("Ankka pysyy pinnalla.")
 
class Ihminen:
    def vaaku(self):
        print("Ihminen imitoi ankkaa.")
    def ui(self):
        print("Ihminen uppoaa.")
    def name(self):
        print("Arto Wikla")
 
def ankkalampi(ankka):
    ankka.vaaku()
    ankka.ui()
 
aku = Ankka()
arto = Ihminen()
ankkalampi(aku)
ankkalampi(arto)

\end{verbatim}
\end{samepage}

Esimerkissä määritellään kaksi luokkaa, \verb+Ankka+ ja \verb+Ihminen+ sekä funktio \verb+ankkalampi+. Funktio ei välitä siitä, onko sen parametrin tyyppinä \verb+Ankka+, vaan sitä voi kutsua myös luokan \verb+Ihminen+ ilmentymällä, sillä luokassa toteutetaan funktion vaatimat metodit. Javassa samantapainen käyttäytyminen toteutettaisiin perinnän tai rajapintojen avulla.

Duck typingin lisäksi Pythonissa käytetään tyyppipäättelyä ennen versiota 3 \cite{python2ref}. Tyyppipäättelyn säännöt vaihtelevat Pythonin varhaisempien versioiden välillä suuresti, jonka vuoksi ohjelmointikielen referenssi ei tarjoa tarkkaa tyyppipäättelysäännöstöä, vaan ainoastaan epävirallisia ohjenuoria. Pythonin versiosta 3 tyyppipäättely on kokonaan karsittu.

\section{Laskennan kapselointi}

\subsection{COBOL}

Muistilistaa:

- "Support for complexity management is minimal in COBOL, with no language features which support any structures larger than subprogram modules." ( http://archive.adaic.com/docs/reports/lawlis/m.htm )

-  Funktioista COBOL ANSI-85 ( http://public.support.unisys.com/aseries/docs/clearpath-mcp-13.0/pdf/86001518-310.pdf )

- Object Oriented COBOL (2002) tukee nimettyjä funktioita ja funktioprototyyppejä, sekä tietysti olioita/perintää/polyformismia (http://en.wikipedia.org/wiki/COBOL)

- Kielessä ei luontaista tukea rinnakkaislaskennalle ( http://archive.adaic.com/docs/reports/lawlis/m.htm ) mutta osa vendoreista tarjoaa apuvälineitä rinnakkaisuuteen (esim. http://supportline.microfocus.com/documentation/books/oc41books/prconc.htm )

\subsection{Python}

Pythonissa funktioiden parametrit ovat arvoparametreja. Lähestulkoon kaikki esitetään kielessä olioina, ja arvoparametrit ovat viitteitä olioihin; ne siis toimivat samalla tavalla kuin parametrina annetut oliot Javassa. 

Funktioiden parametrit ovat tavallisesti ns. \textit{positional-or-keyword}-parametreja \cite{glossary}. Tämä tarkoittaa sitä, että funktiokutsussa voi välittää argumentin joko sen sijainnin perusteella tai käyttämällä avainsanaa. Parametrille voi määritellä oletusarvon. Tällöin vastaavan argumentin voi jättää funktiokutsusta pois ja parametrin arvoksi annetaan määrätty oletusarvo. Ilman oletusarvoa olevat parametrit on listattava funktion määritelmässä ensimmäisenä, ja niiden jälkeen tulevat oletusarvolliset parametrit.



Seuraavan funktion parametreista kahdella on oletusarvo ja yhdellä ei:

\begin{verbatim}
def tervehdi(nimi, tervehdys="Hei", viesti=None):
    print tervehdys, nimi    
    if viesti:
        print viesti      
\end{verbatim}

Parametrilla \verb+tervehdys+ on oletusarvo \verb+hei+ ja parametrilla \verb+viesti+ oletusarvo \verb+None+. Funktio tulostaa parametrit \verb+tervehdys+ ja \verb+nimi+, ja tutkii parametrin \verb+viesti+ arvoa. Jos se on jotakin muuta kuin tyhjä merkkijono tai \verb+None+, arvo tulostetaan.  

Pythonissa funktiokutsussa funktiolle välitettävät argumentit voivat olla avainsana-argumentteja (keyword argument) tai "tavallisia" argumentteja \cite{glossary}. Avainsana-argumentissa argumenttia edeltää tunniste, joka kertoo, mistä funktion parametrista on kyse. Avainsana-argumentit voivat olla funktiokutsussa keskenään eri järjestyksessä kuin vastaavat parametrit funktion määritelmässä. Argumentit, joissa ei käytetä parametrin tunnistetta, on annettava funktion määritelmän parametrilistauksen mukaisessa järjestyksessä. 

Yllä määriteltyä funktiota \verb+tervehdi+ kutsuttaessa vain yksi argumentti on  pakollinen. Funktiokutsut erilaisilla argumenteilla tuottavat seuraavanlaisia tulostuksia:

\begin{samepage}
\begin{verbatim}
>>> tervehdi("Pekka", "Moi")
Moi Pekka
\end{verbatim}
\end{samepage}

\begin{samepage}
\begin{verbatim}
>>> tervehdi("Pekka", viesti="Kvaak kvaak")
Hei Pekka
Kvaak kvaak
\end{verbatim}
\end{samepage}

\begin{samepage}
\begin{verbatim}
>>> tervehdi(viesti="Opettele Pythonia", nimi="Pekka", tervehdys="Terve")
Terve Pekka
Opettele Pythonia
\end{verbatim}
\end{samepage}

Suoritusaikaiseen virheeseen johtavia funktiokutsuja puolestaan olisivat esimerkiksi kutsut \verb+tervehdi()+, \verb+tervehdi("Pekka", "Moi", tervehdys="Terve")+ sekä\\ \verb+tervehdi(tervehdys="Moi", "Pekka")+.

Suoritusaikaisen virheen sattuessa Python-tulkki nostaa poikkeuksen \cite{everythingreturnedexception}. Poikkeus voidaan nostaa myös ohjelmakoodissa käyttämällä \verb+raise+-lausetta. Poikkeuskäsittelijä määritellään \verb+try..except+-lauseella, joka muistuttaa Javan \verb+try..catch+-rakennetta. Poikkeuskäsittelijällä voi olla useita \verb+except+-haaroja, ja Javan tavoin tilanteeseen sopiva haara valitaan poikkeuksen luokan mukaan.

Pythonissa on tuki rinnakkaiselle ohjelmoinnille. Kielen \verb+threading+-kirjasto tarjoaa tähän esimerkiksi säikeet, lukot ja semaforit. \verb+Queue+-moduuli tarjoaa turvallisen tavan säikeiden käsittelyyn.

\section{Etuja ja haittoja}

Pythonissa laajasti hyödynnetty duck typing mahdollistaa samojen funktioiden käyttämisen useille olioille ilman rajapintoja ja perintää. Tyyppitarkistusten puutteessa duck typing kuitenkin turvautuu siihen, että sitä hyödyntävät funktiot ja ohjelmakoodi on luotettavasti dokumentoitu ja testattu. Esimerkiksi Javan rajapinnat ja perintä toimivat osaltaan selkeytyksenä ja dokumentaationa sille, mitä eri metodit vaativat parametreiltään.



\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

\end{document}