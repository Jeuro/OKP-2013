\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{caption}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{COBOL ja Python: Tyypitys ja laskennan kapselointi}
\author{Erkki Heino, Tero Huomo, Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{Tyyppijärjestelmät}

\subsection{COBOL}

\subsubsection{Alkeis- ja perustyypit}

Kielen eri toteutuksille yhtenäisten perustyyppien lisäksi COBOLin kääntäjien toteuttajat ja levittäjät tarjoavat usein lisää valmiita perustyyppejä \cite{wikipediacobol}. Suurin osa tarjoaa esimerkiksi osoittimet ja bittikentät (bit field).

\subsubsection{Tyypitys}

COBOLin tyypityksestä on ristiriitaisia käsityksiä. Wikipedian \cite{wikipediacobol} mukaan COBOL on vahvasti ja staattisesti tyypitetty kieli. Michael Coughlanin COBOL Tutorial \cite{cobolintro} kuitenkin väittää, ettei kääntäjä tee tyyppitarkistuksia, ja COBOL olisi heikosti tyypitetty. Coughlanin mukaan esimerkiksi ei-numeerinen arvo on mahdollista sijoittaa numeerista tietoa sisältävään muuttujaan. Kun väärää tietotyyppiä sisältävällä muuttujalla yritetään tehdä laskutoimituksia, COBOL-ohjelma kaatuu suorituksenaikaiseen virheeseen.

COBOLin oliolaajennos, Object-Oriented COBOL, sisältää sekä vahvan että heikon tyypityksen piirteitä \cite{objectorientedcobol}.

\subsection{Python}

\subsubsection{Alkeis- ja perustyypit}

Pythonissa ei ole erikseen alkeistyyppejä, vaan Pythonissa kaikki on ilmaistu olioina tai olioiden välisinä suhteina \cite{python2ref}. Jokaisella oliolla on \textit{identiteetti} (identity), tyyppi ja arvo. Identiteetti on olion luonnin jälkeen muuttumaton. Identiteettiä voidaan ajatella olion osoitteena muistissa. Myös olion tyyppi on muuttumaton. Tietyissä kontrolloiduissa tilanteissa tyyppiä on mahdollista muuttaa, mutta usein tyyppimuunnoksilla voi olla odottamattomia seurauksia.

Kun kaikki on ilmaistu olioina, Pythonissa myös esimerkiksi None on olio. None on vastaavuus Java-kielen null-arvolle. Toisin kuin Pythonin None, Javan null ei kuitenkaan ole olio, eikä sillä ole tyyppiä.

Kielessä on valmiina useita kymmeniä sisäänrakennettuja tyyppejä, jotka on lueteltu Pythonin tyyppihierarkiassa \cite{python2ref}. Valmiita numeerisia tyyppejä ovat esimerkiksi totuusarvot, kompleksiluvut, kokonaisluvut ja reaaliluvut. Pythonin versiossa 2 kokonaislukuja kuvaavat kiinteän mittainen \verb+int+ ja rajattoman pituisen kokonaisluvun mahdollistava \verb+long+. Pythonin versiossa 3 ei ole kiinteän pituisia kokonaislukuja lainkaan, vaan siinä \verb+int+-tyyppi vastaa version 2 \verb+long+-tyyppiä \cite{python3ref}. Reaalilukujen ja kompleksilukujen arvoalueet voivat riippua käytettävästä konearkkitehtuurista, virtuaalimuistin määrästä sekä kääntäjän asetuksista. Pythonissa ei ole valmiina olemassa erillistä character-tyyppiä, vaan yksittäiset merkit ovat merkkijonoja. Erilaiset laajennusmoduulit lisäävät tyyppejä Javan kirjastojen tapaan.

\subsubsection{Tyypitys}

Python on vahvasti tyypitetty kieli \cite{staticvsdynamic}. Tietyn tyyppiselle muuttujalle ei voida tehdä toisen tyypin operaatioita ennen eksplisiittistä tyyppimuunnosta.

\begin{samepage}
\begin{verbatim}
a = 5
b = "9"
c = a + int(b)
\end{verbatim}
\end{samepage}

Esimerkissä \verb+b+ sisältää merkkijonon "9", mutta yhteenlaskussa merkkijonosta jäsennetään kokonaisluku. Jos kokonaislukujäsennyksen jättää tekemättä, antaa ohjelma kyseisellä rivillä poikkeuksen. 

Python on dynaamisesti tyypitetty kieli. Suoritusaikana muuttujan tyyppi ei ole sidottu, vaan muuttujaan voi dynaamisesti sitoa eri vaiheessa eri tyyppisiä olioita. Seuraavassa esimerkissä muuttuja \verb+a+ saa ensin kokonaislukuarvon 5. Sen jälkeen muuttujan \verb+a+ arvoksi muutetaan merkkijono "Hei".

\begin{samepage}
\begin{verbatim}
a = 5
a = "Hei"
\end{verbatim}
\end{samepage}

Pythonissa käytetään \textit{duck typing} -ohjelmointiparadigmaa \cite{ducktyping}. Olioiden tyyppiä tärkeämpää ovat niiden toteuttamat ominaisuudet ja metodit. Käytännössä tämä tarkoittaa sitä, että funktioiden parametreina annettujen olioiden tyyppiä ei tarkisteta suoritettavassa funktiossa. Jos parametrina ollut olio ei toteuta funktion parametrilta kutsuttavia metodeja, funktio signaloi suorituksenaikaisen virhetilanteen.

\begin{samepage}
\begin{verbatim}
class Ankka:
    def vaaku(self):
        print("Vaaaak!")
    def ui(self):
        print("Ankka pysyy pinnalla.")
 
class Ihminen:
    def vaaku(self):
        print("Ihminen imitoi ankkaa.")
    def ui(self):
        print("Ihminen uppoaa.")
    def name(self):
        print("Arto Wikla")
 
def ankkalampi(ankka):
    ankka.vaaku()
    ankka.ui()
 
aku = Ankka()
arto = Ihminen()
ankkalampi(aku)
ankkalampi(arto)

\end{verbatim}
\end{samepage}

Esimerkissä määritellään kaksi luokkaa, \verb+Ankka+ ja \verb+Ihminen+ sekä funktio \verb+ankkalampi+. Funktio ei välitä siitä, onko sen parametrin tyyppinä \verb+Ankka+, vaan sitä voi kutsua myös luokan \verb+Ihminen+ ilmentymällä, sillä luokassa toteutetaan funktion vaatimat metodit. Javassa samantapainen käyttäytyminen toteutettaisiin perinnän tai rajapintojen avulla.

Duck typingin lisäksi Pythonissa käytetään tyyppipäättelyä ennen versiota 3 \cite{python2ref}. Tyyppipäättelyn säännöt vaihtelevat Pythonin varhaisempien versioiden välillä suuresti, jonka vuoksi ohjelmointikielen referenssi ei tarjoa tarkkaa tyyppipäättelysäännöstöä, vaan ainoastaan epävirallisia ohjenuoria. Pythonin versiosta 3 tyyppipäättely on kokonaan karsittu.

\section{Laskennan kapselointi}

\subsection{COBOL}

\subsubsection{Parametrivälitys}
COBOLissa parametreja voidaan välittää joko arvo- tai viiteparametreina. Kutsuja määrittää, välitetäänkö parametri arvo- vai viitesemantiikalla. Kuvassa 1 nähdään esimerkki aliohjelmakutsuista.

\begin{small}
\begin{minipage}[t]{0.55\textwidth}
\begin{verbatim}
IDENTIFICATION DIVISION.
PROGRAM-ID. ENSIMMAINEN.
ENVIRONMENT DIVISION.
DATA DIVISION.
WORKING-STORAGE SECTION.
77 OMA    PIC X(20) VALUE "EKAN ARVO".
PROCEDURE DIVISION.
   * KUTSUTAAN TOISTA (ARVOPARAMETRI)
   CALL "TOINEN" USING BY VALUE OMA.
   * ENSIMMAISEN MUUTTUJA EI MUUTTUNUT
   DISPLAY OMA.
   * KUTSUTAAN TOISTA (VIITEPARAMETRI)
   CALL "TOINEN" USING BY REFERENCE OMA.
   * ENSIMMAISEN MUUTTUJA MUUTTUI
   DISPLAY OMA.
   END RUN.
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\begin{verbatim}
IDENTIFICATION DIVISION.
PROGRAM-ID. TOINEN.
ENVIRONMENT DIVISION.
DATA DIVISION.
WORKING-STORAGE SECTION.
LINKAGE SECTION.
77 PARAMETRI    PIC X(20).
PROCEDURE DIVISION USING PARAMETRI.
   MOVE "TOKAN ARVO" TO PARAMETRI.
   EXIT PROGRAM.
\end{verbatim}
\end{minipage}
\captionof{figure}{Parametrivälitys COBOLissa}
\label{fig:listings}
\end{small}

Ohjelmassa \verb+ENSIMMAINEN+ kutsutaan kaksi kertaa ohjelmaa \verb+TOINEN+: ensimmäisellä kerralla välitetään muuttujan \verb+OMA+ arvo ja toisella viite samaiseen muuttujaan. Aliohjelma \verb+TOINEN+ muuttaa parametrina saadun muuttujan arvoa. Ohjelma tulostaa:
\begin{verbatim}
EKAN ARVO
TOKAN ARVO
\end{verbatim}

Kutsu 

\verb+CALL "TOINEN" USING BY VALUE OMA+ 

tarkoittaa, että kutsutaan ohjelmaa \verb+TOINEN+ ja välitetään parametrina muuttujan \verb+OMA+ arvo. 

\verb+CALL "TOINEN" USING BY REFERENCE OMA+ 

sen sijaan tarkoittaa, että samaiselle aliohjelmalle välitetään parametrina viite muuttujaan \verb+OMA+.

\subsubsection{Poikkeuskäsittely ja rinnakkaisuus}

COBOLista puuttuu luontainen tuki rinnakkaislaskennalle \cite{lawlis}. Osa COBOLin välittäjistä tarjoaa uudempiin COBOLin versioihin apuvälineitä rinnakkaisuuden toteuttamista varten. Yksi tällainen on Micro Focus \cite{mfocus}.

Muistilistaa:

- "Support for complexity management is minimal in COBOL, with no language features which support any structures larger than subprogram modules." ( http://archive.adaic.com/docs/reports/lawlis/m.htm )

-  Funktioista COBOL ANSI-85 ( http://public.support.unisys.com/aseries/docs/clearpath-mcp-13.0/pdf/86001518-310.pdf )

- Object Oriented COBOL (2002) tukee nimettyjä funktioita ja funktioprototyyppejä, sekä tietysti olioita/perintää/polyformismia (http://en.wikipedia.org/wiki/COBOL)

\subsection{Python}

Pythonissa funktioiden parametrit ovat arvoparametreja. Lähestulkoon kaikki esitetään kielessä olioina, ja arvoparametrit ovat viitteitä olioihin; ne siis toimivat samalla tavalla kuin parametrina annetut oliot Javassa. 

\subsubsection{Parametrivälitys}

Funktioiden parametrit ovat tavallisesti ns. \textit{positional-or-keyword}-parametreja \cite{glossary}. Tämä tarkoittaa sitä, että funktiokutsussa voi välittää argumentin joko sen sijainnin perusteella tai käyttämällä avainsanaa. Parametrille voi määritellä oletusarvon. Tällöin vastaavan argumentin voi jättää funktiokutsusta pois ja parametrin arvoksi annetaan määrätty oletusarvo. Ilman oletusarvoa olevat parametrit on listattava funktion määritelmässä ensimmäisenä, ja niiden jälkeen tulevat oletusarvolliset parametrit.

Seuraavan funktion parametreista kahdella on oletusarvo ja yhdellä ei:

\begin{samepage}
\begin{verbatim}
def tervehdi(nimi, tervehdys="Hei", viesti=None):
    print tervehdys, nimi    
    if viesti:
        print viesti      
\end{verbatim}
\end{samepage}

Parametrilla \verb+tervehdys+ on oletusarvo \verb+hei+ ja parametrilla \verb+viesti+ oletusarvo \verb+None+. Funktio tulostaa parametrit \verb+tervehdys+ ja \verb+nimi+, ja tutkii parametrin \verb+viesti+ arvoa. Jos se on jotakin muuta kuin tyhjä merkkijono tai \verb+None+, arvo tulostetaan.

Pythonissa funktiokutsussa funktiolle välitettävät argumentit voivat olla avainsana-argumentteja (keyword argument) tai "tavallisia" argumentteja \cite{glossary}. Avainsana-argumentissa argumenttia edeltää tunniste, joka kertoo, mistä funktion parametrista on kyse. Avainsana-argumentit voivat olla funktiokutsussa keskenään eri järjestyksessä kuin vastaavat parametrit funktion määritelmässä. Argumentit, joissa ei käytetä parametrin tunnistetta, on annettava funktion määritelmän parametrilistauksen mukaisessa järjestyksessä.

Yllä määriteltyä funktiota \verb+tervehdi+ kutsuttaessa vain yksi argumentti on  pakollinen. Funktiokutsut erilaisilla argumenteilla tuottavat seuraavanlaisia tulostuksia:

\begin{samepage}
\begin{verbatim}
>>> tervehdi("Pekka", "Moi")
Moi Pekka
\end{verbatim}
\end{samepage}

\begin{samepage}
\begin{verbatim}
>>> tervehdi("Pekka", viesti="Kvaak kvaak")
Hei Pekka
Kvaak kvaak
\end{verbatim}
\end{samepage}

\begin{samepage}
\begin{verbatim}
>>> tervehdi(viesti="Opettele Pythonia", nimi="Pekka", tervehdys="Terve")
Terve Pekka
Opettele Pythonia
\end{verbatim}
\end{samepage}

Funktio voidaan määrittää myös siten, että sitä voidaan kutsua mielivaltaisilla argumenteilla:

\begin{samepage}
\begin{verbatim}
def mielivaltainen(*parametrit, **avainsanaparametrit):
    for parametri in parametrit:
        print parametri
    for avain, arvo in avainsanaparametrit.items():
        print avain, arvo
\end{verbatim}
\end{samepage}

Funktio \verb+mielivaltainen+ tulostaa sille annetut argumentit ja avainsana-argumenttien nimet. Esimerkiksi kutsulla \verb+mielivaltainen("eka", "toka", kolmas="kolmonen")+ funktio tulostaa:

\begin{verbatim}
eka
toka
kolmas kolmonen
\end{verbatim}

Avainsanattomat argumentit ovat saatavilla monikossa (tuple) \verb+parametrit+ ja avainsana-argumentit assosiaatiotaulussa (dictionary) \verb+avainsanaparametrit+. Asteriskit määrittävät muodollisten parametrien tarkoituksen: yhdellä asteriskilla alkava parametri kuvaa avainsanattomia argumentteja ja kahdella asteriskilla alkava avainsana-argumentteja. Funktion määrittelyssä voidaan määrittää myös nimettyjä muodollisia parametreja, kunhan ne ovat ennen asteriskeilla varustettuja parametreja. \verb+*+-alkuinen parametri on oltava aina ennen \verb+**+-alkuista parametria funktion määrittelyssä \cite{pycontrolflow}.

\subsubsection{Poikkeuskäsittely ja rinnakkaisuus}

Edellisessä luvussa määritellyn \verb+tervehdi+-funktion kutsuminen esimerkiksi seuraavilla argumenteilla johtaisi suoritusaikaisiin virheisiin:  

\begin{samepage}
\begin{verbatim}
>>> tervehdi()
TypeError: tervehdi() takes at least 1 argument (0 given)

>>> tervehdi("Pekka", "Moi", tervehdys="Terve")
TypeError: tervehdi() got multiple values for keyword argument 'tervehdys'
\end{verbatim}
\end{samepage}

Suoritusaikaisen virheen sattuessa Python-tulkki nostaa poikkeuksen \cite{everythingreturnedexception}. Poikkeus voidaan nostaa myös ohjelmakoodissa käyttämällä \verb+raise+-lausetta. Poikkeuskäsittelijä määritellään \verb+try..except+-lauseella, joka muistuttaa Javan \verb+try..catch+-rakennetta. Poikkeuskäsittelijällä voi olla useita \verb+except+-haaroja, ja Javan tavoin tilanteeseen sopiva haara valitaan poikkeuksen luokan mukaan.

Pythonissa on tuki rinnakkaiselle ohjelmoinnille. Kielen standardikirjaston \verb+threading+-moduuli tarjoaa tähän esimerkiksi säikeet, lukot ja semaforit \cite{threading}, ja \verb+Queue+-moduuli tarjoaa turvallisen tavan säikeiden käsittelyyn \cite{queue}. CPythonissa, joka on laajimmin käytetty Pythonin toteutus, säikeet eivät kuitenkaan voi olla suoritettavina samanaikaisesti, sillä CPythonin muistinhallinta ei ole säieturvallinen \cite{gil}.

\section{Etuja ja haittoja}

Pythonissa laajasti hyödynnetty duck typing mahdollistaa samojen funktioiden käyttämisen useille olioille ilman rajapintoja ja perintää. Tyyppitarkistusten puuttuessa duck typing kuitenkin turvautuu siihen, että sitä hyödyntävät funktiot ja ohjelmakoodi ovat luotettavasti dokumentoituja ja testattuja. Esimerkiksi Javan rajapinnat ja perintä toimivat osaltaan selkeytyksenä ja dokumentaationa sille, mitä eri metodit vaativat parametreiltään.

Pythonin parametrien oletusarvot mahdollistavat usein lyhyemmän ja selkeämmän ilmaisutavan kuin esimerkiksi Java, jossa oletusarvojen puutetta korvataan kuormittamalla metodeja. Jos samasta metodista tarvitsee neljä eri vaihtoehtoa, joutuu Java-ohjelmoija luomaan neljä samannimistä metodia eri parametrivaihtoehdoilla. Pythonissa riittää yksi, jossa on ilmaistu vapaaehtoisten parametrien oletusarvot.

COBOLin rajattu tuki rinnakkaisohjelmoinnille hankaloittaa tehokkaiden rinnakkaisuuteen perustuvien ohjelmien ohjelmoimista kielellä. COBOL-ohjelmia käytetään usein tietokantojen kanssa. Tällöin ohjelmasta voi käynnistää useita instansseja, ja relaatiotietokannan toteutus huolehtii yhteiskäyttöisen tietokannan eheydestä ja tiedon muokkaamisen rinnakkaisuudesta.

\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

\end{document}