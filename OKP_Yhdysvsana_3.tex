\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{COBOL ja Python: Tyypitys ja laskennan kapselointi}
\author{Erkki Heino, Tero Huomo, Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{Tyyppij‰rjestelm‰t}

\subsection{COBOL}

Kielen eri toteutuksille yhten‰isten perustyyppien lis‰ksi COBOLin k‰‰nt‰jien toteuttajat ja levitt‰j‰t tarjoavat usein lis‰‰ valmiita perustyyppej‰ \cite{wikipediacobol}. Suurin osa tarjoaa esimerkiksi osoittimet ja bittikent‰t (bit field).

\subsubsection{Tyypitys}

COBOLin tyypityksest‰ on ristiriitaisia k‰sityksi‰. Wikipedian \cite{wikipediacobol} mukaan COBOL on vahvasti ja staattisesti tyypitetty kieli. Michael Coughlanin COBOL Tutorial \cite{cobolintro} kuitenkin v‰itt‰‰, ettei k‰‰nt‰j‰ tee tyyppitarkistuksia, ja COBOL olisi heikosti tyypitetty. Doughlanin mukaan esimerkiksi ei-numeerinen arvo on mahdollista sijoittaa numeerista tietoa sis‰lt‰v‰‰n muuttujaan. Kun v‰‰r‰‰ tietotyyppi‰ sis‰lt‰v‰ll‰ muuttujalla yritet‰‰n tehd‰ laskutoimituksia, COBOL-ohjelma kaatuu suorituksenaikaiseen virheeseen. 

Vuonna 2002 julkaistu Object Oriented COBOL sis‰lt‰‰ sek‰ vahvan ett‰ heikon tyypityksen piirteit‰ \cite{objectorientedcobol}.

\subsection{Python}

\subsubsection{Alkeis- ja perustyypit}

Pythonissa ei ole erikseen alkeistyyppej‰, vaan Pythonissa kaikki on ilmaistu olioina tai olioiden v‰lisin‰ suhteina \cite{python2ref}. Jokaisella oliolla on \textit{identiteetti} (identity), tyyppi ja arvo. Identiteetti on olion luonnin j‰lkeen muuttumaton. Identiteetti‰ voidaan ajatella olion osoitteena muistissa. Myˆs olion tyyppi on muuttumaton. Tietyiss‰ kontrolloiduissa tilanteissa tyyppi‰ on mahdollista muuttaa, mutta usein tyyppimuunnoksilla voi olla odottamattomia seurauksia.

Kun kaikki on ilmaistu olioina, Pythonissa myˆs esimerkiksi None on olio. None on vastaavuus Java-kielen null-arvolle. Toisin kuin Pythonin None, Javan null ei kuitenkaan ole olio, eik‰ sill‰ ole tyyppi‰.

Kieless‰ on valmiina useita kymmeni‰ sis‰‰nrakennettuja tyyppej‰, jotka on lueteltu Pythonin tyyppihierarkiassa \cite{python2ref}. Valmiita numeerisia tyyppej‰ ovat esimerkiksi totuusarvot, kompleksiluvut, kokonaisluvut ja reaaliluvut. Pythonin versiossa 2 kokonaislukuja kuvaavat kiinte‰n mittainen \verb+int+ ja rajattoman pituisen kokonaisluvun mahdollistava \verb+long+. Pythonin versiossa 3 ei en‰‰ ole kiinte‰n pituisia kokonaislukuja lainkaan, vaan ainoastaan \verb+long+ \cite{python3ref}. Reaalilukujen ja kompleksilukujen arvoalueet voivat riippua k‰ytett‰v‰st‰ konearkkitehtuurista, virtuaalimuistin m‰‰r‰st‰ sek‰ k‰‰nt‰j‰n asetuksista. Pythonissa ei ole valmiina olemassa erillist‰ character-tyyppi‰, vaan yksitt‰iset merkit ovat merkkijonoja. Erilaiset laajennusmoduulit lis‰‰v‰t tyyppej‰ Javan kirjastojen tapaan.

\subsubsection{Tyypitys}

Python on vahvasti tyypitetty kieli \cite{staticvsdynamic}. Tietyn tyyppiselle muuttujalle ei voida tehd‰ toisen tyypin operaatioita ennen eksplisiittist‰ tyyppimuunnosta.

\begin{samepage}
\begin{verbatim}
a = 5
b = "9"
c = a + int(b)
\end{verbatim}
\end{samepage}

Esimerkiss‰ \verb+b+ sis‰lt‰‰ merkkijonon "9", mutta yhteenlaskussa merkkijonosta j‰sennet‰‰n kokonaisluku. Jos kokonaislukuj‰sennyksen j‰tt‰‰ tekem‰tt‰, antaa ohjelma kyseisell‰ rivill‰ poikkeuksen. 

Suoritusaikana muuttujan tyyppi ei ole sidottu, vaan muuttujaan voi dynaamisesti sitoa eri vaiheessa eri tyyppisi‰ olioita. Seuraavassa esimerkiss‰ muuttuja \verb+a+ saa ensin kokonaislukuarvon 5. Sen j‰lkeen muuttujan \verb+a+ arvoksi muutetaan merkkijono "Hei".

\begin{samepage}
\begin{verbatim}
a = 5
a = "Hei"
\end{verbatim}
\end{samepage}

Pythonissa k‰ytet‰‰n lis‰ki \textit{duck typing} -ohjelmointiparadigmaa \cite{ducktyping}. Olioiden tyyppi‰ t‰rke‰mp‰‰ ovat niiden toteuttamat ominaisuudet ja metodit. K‰yt‰nnˆss‰ t‰m‰ tarkoittaa sit‰, ett‰ funktioiden parametreina annettujen olioiden tyyppi‰ ei tarkisteta suoritettavassa funktiossa. Jos parametrina ollut olio ei toteuta funktion parametrilta kutsuttavia metodeja, funktio signaloi suorituksenaikaisen virhetilanteen.

\begin{samepage}
\begin{verbatim}
class Ankka:
    def vaaku(self):
        print("Vaaaak!")
    def ui(self):
        print("Ankka pysyy pinnalla.")
 
class Ihminen:
    def vaaku(self):
        print("Ihminen imitoi ankkaa.")
    def ui(self):
        print("Ihminen uppoaa.")
    def name(self):
        print("Arto Wikla")
 
def ankkalampi(ankka):
    ankka.vaaku()
    ankka.ui()
 
aku = Ankka()
arto = Ihminen()
ankkalampi(aku)
ankkalampi(arto)

\end{verbatim}
\end{samepage}

Esimerkiss‰ m‰‰ritell‰‰n kaksi luokkaa, \verb+Ankka+ ja \verb+Ihminen+ sek‰ funktio \verb+ankkalampi+. Funktio ei v‰lit‰ siit‰, onko sen parametrin tyyppin‰ \verb+Ankka+, vaan sit‰ voi kutsua myˆs luokan \verb+Ihminen+ ilmentym‰ll‰, sill‰ luokassa toteutetaan funktion vaatimat metodit. Javassa samantapainen k‰ytt‰ytyminen toteutettaisiin perinn‰n tai rajapintojen avulla.

Duck typingin lis‰ksi Pythonissa k‰ytet‰‰n tyyppip‰‰ttely‰ ennen versiota 3 \cite{python2ref}. Tyyppip‰‰ttelyn s‰‰nnˆt vaihtelevat Pythonin varhaisempien versioiden v‰lill‰ suuresti, jonka vuoksi ohjelmointikielen referenssi ei tarjoa tarkkaa tyyppip‰‰ttelys‰‰nnˆstˆ‰, vaan ainoastaan ep‰virallisia ohjenuoria. Pythonin versiosta 3 tyyppip‰‰ttely on kokonaan karsittu.

\section{Laskennan kapselointi}

\subsection{COBOL}

Muistilistaa:

- "Support for complexity management is minimal in COBOL, with no language features which support any structures larger than subprogram modules." ( http://archive.adaic.com/docs/reports/lawlis/m.htm )

-  Funktioista COBOL ANSI-85 ( http://public.support.unisys.com/aseries/docs/clearpath-mcp-13.0/pdf/86001518-310.pdf )

- Object Oriented COBOL (2002) tukee nimettyj‰ funktioita ja funktioprototyyppej‰, sek‰ tietysti olioita/perint‰‰/polyformismia (http://en.wikipedia.org/wiki/COBOL)

- Kieless‰ ei luontaista tukea rinnakkaislaskennalle ( http://archive.adaic.com/docs/reports/lawlis/m.htm ) mutta osa vendoreista tarjoaa apuv‰lineit‰ rinnakkaisuuteen (esim. http://supportline.microfocus.com/documentation/books/oc41books/prconc.htm )
\subsection{Python}

\section{Etuja ja haittoja}

Pythonissa laajasti hyˆdynnetty duck typing mahdollistaa samojen funktioiden k‰ytt‰misen useille olioille ilman rajapintoja ja perint‰‰. Tyyppitarkistusten puutteessa duck typing kuitenkin turvautuu siihen, ett‰ sit‰ hyˆdynt‰v‰t funktiot ja ohjelmakoodi on luotettavasti dokumentoitu ja testattu. Esimerkiksi Javan rajapinnat ja perint‰ toimivat osaltaan selkeytyksen‰ ja dokumentaationa sille, mit‰ eri metodit vaativat parametreilt‰‰n.



\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

\end{document}