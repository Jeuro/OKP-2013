\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{COBOL ja Python: Tyypitys ja laskennan kapselointi}
\author{Erkki Heino, Tero Huomo, Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{Tyyppij‰rjestelm‰t}

\subsection{COBOL}

COBOL on vahvasti ja staattisesti tyypitetty kieli \cite{wikipediacobol}. Olio-orientointunut COBOL (Object Oriented COBOL) sis‰lt‰‰ sek‰ vahvan ett‰ heikon tyypityksen piirteit‰. \cite{objectorientedcobol}

"In COBOL, there are really only three data types -

- numeric

- alphanumeric (text/string)

- alphabetic

The distinction between these data types is a little blurred and only weakly enforced by the compiler. For instance, it is perfectly possible to assign a non-numeric value to a data item that has been declared to be numeric.

The problem with this lax approach to data typing is that, since COBOL programs crash (halt unexpectedly) if they attempt to do computations on items that contain non-numeric data, it is up to the programmer to make sure this never happens."

- http://www.csis.ul.ie/cobol/course/DataDeclaration.htm


Eli k‰‰nt‰j‰ ei tee tyyppitarkistuksia (ei olisi staattinen)? Vai puhuiko teksti k‰ytt‰j‰n syˆtteist‰? (Mik‰ COBOLin versio?)



\subsection{Python}

\subsubsection{Alkeis- ja perustyypit}

Pythonissa ei ole erikseen alkeistyyppej‰, vaan Pythonissa kaikki on ilmaistu olioina tai olioiden v‰lisin‰ suhteina \cite{python2ref}. Jokaisella oliolla on \textit{identiteetti} (identity), tyyppi ja arvo. Identiteetti on olion luonnin j‰lkeen muuttumaton. Identiteetti‰ voidaan ajatella olion osoitteena muistissa. Olion tyyppi on muuttumaton. Tietyiss‰ kontrolloiduissa tilanteissa tyyppi‰ on mahdollista muuttaa, mutta usein tyyppimuunnoksilla voi olla odottamattomia seurauksia.

Pythonissa siis myˆs esimerkiksi None on olio. None on vastaavuus Java-kielen null-arvolle. Toisin kuin Pythonin None, Javan null ei kuitenkaan ole olio, eik‰ sill‰ ole tyyppi‰.

Kieless‰ on valmiina useita kymmeni‰ sis‰‰nrakennettuja tyyppej‰, jotka on lueteltu Pythonin tyyppihierarkiassa \cite{python2ref}. Valmiita numeerisia tyyppej‰ ovat esimerkiksi totuusarvot, kompleksiluvut, kokonaisluvut ja reaaliluvut. Tavalliset kokonaisluvut ovat Javan tapaan 32-bittisi‰. Pythonin versiossa 3 ei ole kiinte‰n pituisia kokonaislukuja \cite{python3ref}. Reaalilukujen ja kompleksilukujen arvoalueet voivat riippua k‰ytett‰v‰st‰ konearkkitehtuurista, virtuaalimuistin m‰‰r‰st‰ sek‰ k‰‰nt‰j‰n asetuksista. Pythonissa ei lis‰ksi ole valmiina olemassa erillist‰ Character-tyyppi‰, vaan yksitt‰iset merkit ovat merkkijonoja. 

Erilaiset laajennusmoduulit lis‰‰v‰t valmiita luokkia Javan kirjastojen tapaan.

\subsubsection{Tyypitys}

Python on vahvasti tyypitetty kieli \cite{staticvsdynamic}. Tietyn tyyppiselle muuttujalle ei voida tehd‰ toisen tyypin operaatioita ennen eksplisiittist‰ tyyppimuunnosta.

\begin{samepage}
\begin{verbatim}
a = 5
b = "9"
c = a + int(b)
\end{verbatim}
\end{samepage}

Esimerkiss‰ \verb+b+ sis‰lt‰‰ merkkijonon "9", mutta yhteenlaskussa merkkijonosta j‰sennet‰‰n kokonaisluku. Jos kokonaislukuj‰sennyksen j‰tt‰‰ tekem‰tt‰, antaa ohjelma kyseisell‰ rivill‰ poikkeuksen. 

Suoritusaikana muuttujan tyyppi ei ole sidottu, vaan muuttujaan voi dynaamisesti sitoa eri vaiheessa eri tyyppisi‰ olioita. Seuraavassa esimerkiss‰ muuttuja \verb+a+ saa ensin kokonaislukuarvon 5. Sen j‰lkeen muuttujan \verb+a+ arvoksi muutetaan merkkijono "hei".

\begin{samepage}
\begin{verbatim}
a = 5
a = "Hei"
\end{verbatim}
\end{samepage}

\section{Laskennan kapselointi}

\subsection{COBOL}

Muistilistaa:

- "Support for complexity management is minimal in COBOL, with no language features which support any structures larger than subprogram modules." ( http://archive.adaic.com/docs/reports/lawlis/m.htm )

-  Funktioista COBOL ANSI-85 ( http://public.support.unisys.com/aseries/docs/clearpath-mcp-13.0/pdf/86001518-310.pdf )

- Object Oriented COBOL (2002) tukee nimettyj‰ funktioita ja funktioprototyyppej‰, sek‰ tietysti olioita/perint‰‰/polyformismia (http://en.wikipedia.org/wiki/COBOL)

- Kieless‰ ei luontaista tukea rinnakkaislaskennalle ( http://archive.adaic.com/docs/reports/lawlis/m.htm ) mutta osa vendoreista tarjoaa apuv‰lineit‰ rinnakkaisuuteen (esim. http://supportline.microfocus.com/documentation/books/oc41books/prconc.htm )
\subsection{Python}

\section{Etuja ja haittoja}

\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

\end{document}