\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{caption}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{COBOL ja Python: Datan kapselointi}
\author{Erkki Heino, Tero Huomo, Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{COBOL}

\subsection{Perinteinen COBOL}

COBOLissa tietoa voidaan ryhmitellä muodostamalla tietueita (record) ja ryhmiä (group). \verb+DATA DIVISION+ -osiossa käytettävät muuttujien tasonumerot (level number) määrittävät, minkälaisia kokonaisuuksia muuttujat muodostavat. Seuraavassa esimerkissä on kuvattu opiskelijatietue.

\begin{samepage}
\begin{verbatim}
    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 OPISKELIJA.
       05 NIMI.
           10 ETUNIMI  PIC A(10).
           10 SUKUNIMI PIC A(10).
       05 NUMERO       PIC 9(10).
       05 SUKUPUOLI    PIC A.
           88 MIES     VALUE "M".
           88 NAINEN   VALUE "N".
\end{verbatim}
\end{samepage}

\verb+OPISKELIJA+ on tietue, joka koostuu nimestä, opiskelijanumerosta ja sukupuolesta. Nimi on jaettu kahteen osaan: etunimi ja sukunimi.

Tasonumerot kuvaavat tiedon hierarkian, mutta tietyillä numeroilla on erityismerkitys. Hierarkiaa kuvaavat tasonumerot 02-49. Tasonumero 01 tarkoittaa, että kyseessä on tietue. Merkitsemällä tasonumeroksi 66 voidaan edeltävälle muuttujalle antaa toinen nimi. 77 kuvaa muuttujaa, joka ei ole osa mitään rakennetta. Tason 88 avulla voidaan määrittää muuttujaan liittyviä ehtoja: yllä olevassa esimerkissä opiskelijan sukupuoli on mies, jos muuttujan \verb+SUKUPUOLI+ arvo on M, ja nainen, jos arvo on N \cite[s. I-84]{ansicobol74}. Esimerkiksi voitaisiin tarkistaa, onko opiskelija mies:

\verb+IF MIES OF OPISKELIJA+

Tietueelle voidan antaa arvot kenttä kerrallaan:

\verb+MOVE "ARTO" TO ETUNIMI OF OPISKELIJA.+

Toisaalta koko tietueelle voidaan antaa arvo kerralla:

\verb+MOVE "ARTO      WIKLA     1234567890M" TO OPISKELIJA.+

Välilyöntien määrä johtuu siitä, että etu- ja sukunimikentät on määritetty kymmenen merkin pituisiksi. Kuten nähdään, tietue on pohjimmiltaan vain merkkijono ja sen kentät tämän merkkijonon osia.

Esimerkin tietue sisältää kerrallaan yhden opiskelijan tiedon --- tällaisenaan koodissa ei siis voida käsitellä useampaa opiskelijaa samanaikaisesti. Rakenne voidaan määritellä taulukoksi (table), jolloin samaa rakennetta voidaan käyttää useamman samanrakenteisen tiedon käsittelemiseen ilman saman rakenteen uudelleenmäärittelyä.

Muuttuja määritellään taulukoksi \verb+OCCURS+-lauseen avulla. \verb+OPISKELIJA+ voitaisiin muuttaa taulukoksi muokkaamalla määrittelyä seuraavasti:

\begin{verbatim}
01 OPISKELIJA OCCURS 5 TIMES.
\end{verbatim}

Esimerkiksi taulukon toiseen opiskelijaan viitattaisiin indeksillä 2: \verb+OPISKELIJA(2)+. 
Taulukon sisällä voidaan myös määritellä sisäkkäisiä taulukoita \cite[s. III-3]{ansicobol74}.

\subsection{COBOLin oliolaajennus}

COBOL ei alunperin ole olio-ohjelmointikieli. COBOLista on kuitenkin kehitetty olio-ohjelmoinnin mahdollistava laajennus, Object-oriented COBOL. Ensimmäiset oliolaajennukset COBOLiin tehtiin jo vuonna 1997 \cite{wikipediacobol}. Kieltä laajensivat esimerkiksi Micro Focus sekä IBM. Lopullinen ISO standardi Object-Oriented COBOLille tehtiin vuonna 2002.

Object-Oriented COBOL (jatkossa OO COBOL) lisää kieleen kolme olio-ohjelmointikielen perustavanlaatuista ominaisuutta - tiedon kapseloinnin, perinnän sekä polymorfismin. Olio-ohjelmoinnin lisäyksien syntaksi sekä tarjotut ominaisuudet vaihtelevat suuresti eri toteuttajien välillä. Niiden yhtenäisyys vuoden 2002 ISO standardin kanssa on vaihteleva.

Oliolaajennoksen tärkeimpiä lisäyksiä on mahdollisuus luokkien ja olioiden määrittelyyn. Kuten normaali COBOL-ohjelma, luokka määritellään neljän \textit{osion} (division) avulla. IBM'n toteutus \cite{ibmcobol} ja Micro Focus'n toteutus \cite{mfcobol} vastaavat pitkälti toisiaan. \verb+IDENTIFICATION DIVISION+-osiossa ohjelman tunnuksen sijasta annetaan luokan tunnus, \verb+CLASS ID+, sekä mahdolliset periytymisestä kertovat tiedot. Luokan yhteinen tietosisältö ja metodit luetellaan \verb+FACTORY+-osiossa, olioiden tietosisältö ja metodit \verb+OBJECT+-osiossa. Muihin luokkiin viittaamiseen on varattu erillinen \verb+REPOSITORY+-osio.

Olioiden metodien kutsumiseksi on OO COBOLiin lisätty avainsana \verb+INVOKE+.

\begin{verbatim}
INVOKE ARTONTILI "TALLETA" USING KATEINEN RETURNING KUITTI
\end{verbatim}

Esimerkissä kutsutaan olion \verb+ARTONTILI+ metodia \verb+TALLETA+, jolle annetaan parametriksi muuttujan \verb+KATEINEN+ arvo. Metodin palauttama arvo sijoitetaan muuttujaan \verb+KUITTI+.

Periminen ja rajapintojen toteutus vaihtelee runsaasti. Micro Focus'n Visual COBOL ei mahdollista moniperintää, mutta luokat voivat toteuttaa Javan tyyliin usean rajapinnan \cite{mfcobol}. IBM:n Enterprise COBOL ei määrittele dokumentoinnissa rajapintoja lainkaan, mutta estää moniperinnän \cite{ibmcobol}. Michael Kastenin \cite{kasten} mukaan C++:n tavoin IBM:n OO COBOL kuitenkin  luettelisi erilaisia sääntöjä, joilla usean luokan yhtäaikaista perimisestä kumpuava niin kutsuttu timanttiongelma ratkaistaan. Tästä voidaan päätellä, että OO COBOL on myös tukenut moniperintää. Myös Micro Focus'n varhainen dokumentaatio mainitsee moniperinnän tuen \cite{mfcobolold}.

\section{Python}

Pythonissa muuttujien arvot ovat viitteitä olioihin, ja kielessä kaikki esitetään olioina tai olioiden välisinä suhteina. 

\subsection{Rakenteiset tyypit}
Pythonin tarjoamia sekvenssityyppejä ovat muun muassa lista (\verb+list+) ja monikko (\verb+tuple+). Muita kielen tietorakenteita ovat esimerkiksi joukko (\verb+set+) ja sanakirja (\verb+dict+). Tämä luku pohjautuu pääosin Python-tutoriaalin osioon Data Structures \cite{data}.
 
\textit{Lista} muistuttaa jossain määrin Javan \verb+ArrayList+ia. Listan alkioiden ei kuitenkaan tarvitse olla keskenään samaa tyyppiä \cite{lists}. Listan alkiot erotellaan toisistaan pilkuilla ja listaa ympäröivät hakasulut. Merkintä \verb+[]+ tarkoittaa tyhjää listaa. Listan sisältöä voi muokata sen luomisen jälkeen.

Listoja voi käsitellä monella tavalla. Listaa voidaan esimerkiksi järjestää ja listan alkioita voi lisätä ja poistaa. Listan muokkaamiseen tarkoitettujen metodien lisäksi Pythonissa on listojen käsittelyyn myös funktionaaliselle ohjelmoinnille tyypillisiä funktioita, kuten \verb+map+ ja \verb+filter+. Funktio \verb+map+ saa parametrina funktion ja iteroitavan olion. Funktiota käytetään iteroitavan olion alkioihin, ja \verb+map+-funktio palauttaa näistä tuloksista koostuvan listan. Funktio \verb+filter+ saa myös parametreina funktion ja iteroitavan olion. Se muodostaa listan niistä alkioista, joille parametrina saatu funktio palauttaa arvon \verb+True+. Seuraavassa esimerkissä \verb+map+-funktiolla luodaan luvun kaksi potensseja sisältävä lista:

\begin{verbatim}
>>> map(lambda x: 2**x, range(0, 11))
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
\end{verbatim}

Pythonissa \verb+lambda+ määrittelee anonyymin funktion, jolla on tässä esimerkissä yksi parametri. \verb+range(0,11)+ palauttaa kokonaisluvut nollasta kymmeneen.

Listakomprehensiot (list comprehension) ovat näppärä tapa luoda listoja. Listakomprehensioita käytetään samaan tarkoitukseen kuin \verb+map+- ja \verb+filter+-funktioita, mutta ne ilmaisevat asian tiiviimmin ja selkeämmin. Listakomprehensioita voi olla myös sisäkkäin. Seuraavassa esimerkissä luodaan listakomprehensiolla samanlainen lista, joka yllä luotiin \verb+map+-funktion avulla:

\begin{samepage}
\begin{verbatim}
>>> [2**x for x in range(0, 11)]
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
\end{verbatim}
\end{samepage}

Kun edellisen esimerkin listakomprehensioon lisätään ehtolause, voidaan luoda lista, joka sisältää vain ne luvut, joissa eksponentti on parillinen:

\begin{samepage}
\begin{verbatim}
>>> [2**x for x in range(0,11) if x % 2 == 0]
[1, 4, 16, 64, 256, 1024]
\end{verbatim}
\end{samepage}

\textit{Monikkoa} ympäröivät kaarisulut, ja alkiot erotellaan toisistaan pilkuilla. Monikot muistuttavat hieman listoja, mutta niitä käytetään yleensä eri tarkoituksiin. Toisin kuin listan tapauksessa, kerran luotua monikkoa ei voi muokata. Monikko voi kuitenkin sisältää muuttuvia tietotyyppejä, kuten listoja. Monikon alkiot voivat olla myös toisia monikkoja.

Seuraava esimerkki esittelee monikon purkamista:

\begin{samepage}
\begin{verbatim}
>>> monikko = ("a", 123, 3.14)
>>> x, y, z = monikko
>>> x
"a"
>>> y
123
>>> z
3.14
\end{verbatim}
\end{samepage}

Esimerkissä monikon alkiot sidotaan järjestyksessä muuttujiin \verb+x+, \verb+y+ ja \verb+z+. Kun monikko puretaan, vasemmalla puolella on oltava yhtä monta muuttujaa kuin monikossa on alkioita. Muussa tapauksessa tapahtuu suoritusaikainen virhe.

\textit{Joukko} on järjestämätön tietorakenne, ja se voi sisältää saman alkion korkeintaan kerran. Joukkoihin voi käyttää matemaattisia joukko-operaatioita, kuten yhdistettä, leikkausta ja erotusta.  Python tukee myös joukkokomprehensioita (set comprehension), jotka toimivat listakomprehensioiden tapaan: 

\begin{samepage}
\begin{verbatim}
>>> joukko = {x for x in "nakkivanukas" if x not in "aeiouyäö"}
>>> joukko
set(['k', 'v', 's', 'n'])
\end{verbatim}
\end{samepage}

Esimerkissä luodaan joukko, joka sisältää merkkijonon \verb+nakkivanukas+ ne merkit, jotka eivät ole pieniä vokaaleja. Esimerkistä huomataan, että kukin ehdon täyttävä merkki esiintyy luodussa joukossa vain kerran.

\textit{Sanakirja} sisältää avain-arvo-pareja, ja se vastaa esimerkiksi Javan \verb+HashMap+ia. Sanakirjaan voi lisätä uuden avain-arvo-parin ja sieltä voi hakea arvoa avaimen perusteella. Pareja voi myös poistaa, ja olemassa olevaan avaimeen liittyvää arvoa voi päivittää. Avaimena voi käyttää arvoa, joka ei ole muokattavaa tyyppiä; avaimiksi kelpaavat esimerkiksi merkkijonot, luvut sekä monikot, joiden alkiot eivät ole muokattavia. 

Avaimen ja siihen liittyvän arvon välissä on kaksoispiste, ja parit erotetaan toisistaan pilkuilla. Sanakirjaa ympäröivät aaltosulut, ja merkintä \verb+{}+ tarkoittaa tyhjää sanakirjaa. Seuraavassa esimerkissä käytetään sanakirjaa eläinten ja niiden ääntelyn tallentamiseen:

\begin{samepage}
\begin{verbatim}
>>> elaimet = {"koira": "hau", "kissa": "miu"}
>>> elaimet["seeprapeippo"] = "tööt"
>>> elaimet
{"seeprapeippo": "tööt", "koira": "hau", "kissa": "miu"}
>>> elaimet["seeprapeippo"]
"tööt"
\end{verbatim}
\end{samepage}

Esimerkissä luodaan aluksi sanakirja, jonka avaimet ja arvot ovat merkkijonoja. Sanakirjaan lisätään uusi avain-arvo-pari, ja lopuksi sieltä haetaan avaimeen \verb+seeprapeippo+ liittyvä arvo.

Myös sanakirjoja voi luoda käyttämällä komprehensioita (dict comprehension):

\begin{verbatim}
>>> {x: 2**x for x in (0,1,2,3)}
{0: 1, 1: 2, 2: 4, 3: 8}
\end{verbatim}

Esimerkissä luodaan sanakirja, jonka avaimina ovat kokonaisluvut nollasta kolmeen, ja arvoina luku kaksi korotettuna avaimen osoittamaan potenssiin.

Yleiskäyttöisten kokoelmien lisäksi Pythonissa on myös tehokkaita, tiettyihin käyttötarkoituksiin erikoistuneita kokoelmatyyppejä. Standardikirjaston \verb+collections+-moduulissa on muun muassa tehokas tietorakenne jonojen ja pinojen toteuttamiseen (\verb+deque+) sekä \verb+OrderedDict+, joka toimii kuten tavallinen sanakirja, mutta muistaa lisäksi, missä järjestyksessä alkiot on lisätty \cite{collections}.

\subsection{Oliot ja luokat}

Ennen versiota 2.2 Pythonin luokat erosivat hieman nykyisistä luokista. Itse asiassa vanhanmalliset luokat olivat käytössä rinnakkain uudenmallisten luokkien kanssa Python 3:een asti. Uudenmalliset luokat ovat uusia tyyppejä siinä missä vanhanmallisten olioiden tyyppi on aina sama: \verb+instance+. \cite{python2ref}. Seuraavassa käsitellään uudenmallisia luokkia, ellei toisin mainita.

Python on dynaaminen kieli ja sen oliot ovat hyvin joustavia. Luokka määritellään seuraavalla tavalla:

\begin{samepage}
\begin{verbatim}
class Luokka(object):
    def __init__(self, parametri):
        self.muuttuja = parametri
\end{verbatim}
\end{samepage}

Yllä olevan esimerkin luokassa on määritelty myös konstrukorinomainen \verb+__init__+-metodi. Tätä metodia kutsutaan olion luomisen yhteydessä. Metodi saa ensimmäisenä parametrinaan (self) luokan ilmentymän. Luokasta \verb+Luokka+ luotaisiin instanssi seuraavalla tavalla: \verb+l = Luokka("arvo")+. Parametreille ja muuttujille ei määritetä tyyppiä, joten esimerkinkin metodi hyväksyy minkä tyyppisen muuttujan tahansa --- tässä tapauksessa merkkijonon. \verb+__init__+-metodia ei kuitenkaan vaadita luokan määrittelyssä \cite{pythonclass}.

Muuttujaa \verb+muuttuja+ ei ole määritelty \verb+__init__+-metodin ulkopuolella. Muuttujia voidaan määritellä myös metodin ulkopuolella, mutta silloin ne ovat käytettävissä luokan kautta myös ilman luokan instanssia.

Muuttujille ja metodeille ei voi määrittää näkyvyysalueita: kaikki luokan muuttujat ja metodit ovat käytettävissä kaikkialla, missä luokka on käytettävissä. Konvention mukaan muuttujat ja metodit, joita ei ole tarkoitettu käytettäväksi luokan ulkopuolella, nimetään siten, että ne alkavat alaviivalla. Tämä ei kuitenkaan estä niiden käyttöä. \cite{pythonclass}.

Itse asiassa luokkia tai niiden ilmentymiä ei ole mitenkään suojattu muutoksilta: niiden muuttujia ja metodeja voidaan korvata ja uusia lisätä täysin vapaasti. Jos esimerkiksi luokan \verb+Luokka+ \verb+__init__+-metodi ei miellytä, sen voi korvata vaikka seuraavalla tavalla metodilla, joka ei tee muuta kuin tulostaa "Uusi metodi!":

\begin{verbatim}
>>> def uusi_init(self):
        print "Uusi metodi!"

>>> Luokka.__init__ = uusi_init
>>> l = Luokka()
Uusi metodi!
\end{verbatim}

Metodin tai muuttujan voi myös poistaa: \verb+del Luokka.__init__+. Toisaalta myös täysin uuden metodin lisääminen onnistuu helposti:

\begin{verbatim}
>>> Luokka.puhu = uusi_init
>>> l = Luokka()
>>> l.puhu()
Uusi metodi!
\end{verbatim}

\subsection{Perintä}

Edellisen kappaleen \verb+Luokka+-luokka on uudenmallinen ja täten perii \verb+object+-luokan. Uudenmallinen luokka siis perii joko \verb+object+-luokan tai uudenmallisia luokkia. Vanhanmalliset luokat eivät välttämättä peri mitään luokkaa \cite{python2ref}. Kuvassa 1 nähdään vanhan- ja uudenmallisen luokan määrittelyn syntaktinen ero, kun luokka ei peri mitään "ylimääräistä". Perittävät luokat määritellään siis suluissa luokan nimen jälkeen.

\begin{minipage}[t]{0.5\textwidth}
\begin{verbatim}
class Uusi(object):
    # Uudenmallinen luokka
    pass
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
\begin{verbatim}
class Vanha:
    # Vanhanmallinen luokka
    pass
\end{verbatim}
\end{minipage}
\captionof{figure}{Uudenmallinen ja vanhanmallinen luokka Pythonissa}

Python tukee myös moniperintää. Seuraavassa esimerkissä luokka \verb+C+ perii luokat \verb+A+ ja \verb+B+:
\begin{verbatim}
>>> class A(object): pass
>>> class B(object): pass
>>> class C(A, B): pass
\end{verbatim}

Koska uudenmallinen luokka perii aina vähintään \verb+object+-luokan, joudutaan aina moniperinnän yhteydessä tekemisiin timanttiongelman kanssa. Pythonissa perintäjärjestys ratkaistaan vasemmalta oikealle, syvyyssuunta ensin.  Uudenmallisten luokkien yhteydessä käytetään C3-linearisointia (C3 linearization), joka takaa, ettei yläluokkia kutsuta useampaan otteeseen perintäjärjestyksessä, eikä järjestys muutu uusissa alaluokissa \cite{pythonclass}.

\section{Etuja ja haittoja}

COBOLin olio-ohjelmoinnin mahdollistava laajennus on monimutkaistaa COBOLin syntaksia entisestään. Lisäksi COBOLille tyypillisesti jo yksinkertaisten luokkien määritteleminen tuottaa huomattavan paljon koodirivejä, jos vertailukohteena on esimerkiksi Javan tai varsinkin Pythonin tiivis ilmaisutapa.

Object-Oriented COBOLin toteutukset ovat monimuotoisia ja poikkeavat toisistaan ominaisuuksiltaan. Voidaan kiistellä, mahdollistaako IBM:n toteutus polymorfismia kovinkaan laajasti, sillä kielen referenssissä ei ole lainkaan kuvailtu rajapintoja. Lisäksi muun muassa Micro Focus tukee COBOLin yhteistyötä C-kielen kanssa, kun taas IBM mahdollistaa Javan ja COBOLin yhdistämisen. Yhteistyötuki eri kielten välille lisäävät eroja implementaatioiden välille.

Pythoniin rakennetut kokoelmatyypit ovat selkeitä ja monipuolisia. Useimpiin tarkoituksiin ne ovat myös riittävän tehokkaita. Suurten, moniulotteisten taulukkojen käsittelyyn on kuitenkin olemassa tehokkaampia työkaluja, kuten esimerkiksi laajalti käytetty NumPy-laajennos \cite{numpy}.

\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

\end{document}