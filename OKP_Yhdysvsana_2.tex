\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{COBOL ja Python: Näkyvyysalueet ja laskennan ohjaus}
\author{Erkki Heino, Tero Huomo, Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{Näkyvyysalueet}

Näkyvyysalueet määrittävät, missä osissa koodia muuttujat ovat käytettävissä. Tämän suhteen COBOL ja Python eroavat toisistaan paljon.

\subsection{COBOL}

COBOLissa kaikki muuttujat on määritettävä \verb+DATA DIVISION+ -osiossa ja nämä muuttujat ovat käytettävissä koko kyseisessä ohjelmassa \cite[s. I-97]{ansicobol74}. COBOLin lohkorakenne on siis selvästi litteä.

Ohjelmien muuttujat eivät näy ohjelman ulkopuolelle, joten aliohjelmat eivät voi käsitellä suoraan näitä kutsuvien ohjelmien muuttujia. Aliohjelmalle voidaan kuitenkin välittää muuttujia viiteparametreina, jolloin se voi muuttaa näiden muuttujien arvoja myös kutsuvan ohjelman kontekstissa \cite[s. XII-2]{ansicobol74}.

\subsection{Python}
Python käyttää dynaamista sidontaa \cite{glue}. Pythonin lohkorakenne on syvä, ja ohjelman suoritusaikana käytössä on ainakin kolme sisäkkäistä näkyvyysaluetta \cite{pythonclasses}. Näkyvyysalueita käytetään dynaamisesti. Sisimmällä näkyvyysalueella ovat paikalliset nimet. Mahdollisilla funktioita ympäröivillä funktioilla on omat näkyvyysalueensa, joiden sisältämät nimet eivät ole paikallisia eivätkä globaaleja. Toisiksi uloimmalla näkyvyysalueella ovat moduulin globaalit nimet ja kaikkein uloimmalla kieleen rakennetut nimet. 

Pythonissa luokan näkyvyysalueella määritellyt nimet eivät näy luokan metodeille \cite{pythonexec}. Metodin ensimmäinen argumentti, jolle on tapana antaa nimi \verb+self+, edustaa luokan ilmentymää. Sen kautta metodi voi käyttää luokan ilmentymän muita metodeja ja attribuutteja.

Seuraavassa esimerkissä on kaksi sisäkkäistä funktiota:

% voisi varmaan nimetä fiksummin
\begin{samepage}
\begin{verbatim}
def f1():
    a = 	1	
    def f2():
        b = 2
        print a + b            
    print a
    f2()
    
f1()
\end{verbatim}
\end{samepage}

Funktio \verb+f1+ määrittelee muuttujan \verb+a+ ja funktion \verb+f2+, tulostaa \verb+a+:n arvon ja kutsuu määrittelemäänsä funktiota. Funktio \verb+f2+ määrittelee muuttujan \verb+b+ ja tulostaa muuttujien \verb+a+ ja \verb+b+ arvojen summan. Ohjelma tulostaa luvut 1 ja 3. Muuttuja \verb+a+ on näkyvissä funktion \verb+f1+ ja sen sisäisten funktioiden sisällä. Muuttuja \verb+b+ puolestaan on paikallinen muuttuja, joka on näkyvissä vain \verb+f2+-funktion sisällä. Siihen viittaaminen \verb+f2+-funktion ulkopuolella johtaisi virhetilanteeseen.

Seuraavassa esimerkissä käytetään globaalia muuttujaa:

% nämäkin voisi nimetä fiksummin
\begin{samepage}
\begin{verbatim}
g = 1

def f3():
    global g
    g = 2
    print g
    
f3()
print g
\end{verbatim}
\end{samepage}

Esimerkissä globaalin muuttujan \verb+g+ arvoksi alustetaan ensin luku 1. Funktio \verb+f3+ asettaa \verb+g+:n arvoksi luvun 2 ja myös tulostaa muuttujan arvon. Kun funktiota \verb+f3+ kutsutaan ja sen jälkeen vielä tulostetaan \verb+g+:n arvo, ohjelma tulostaa kaksi kertaa luvun 2. Funktio \verb+f3+ siis käsittelee globaalia muuttujaa. Avainsana \verb+global+ on tärkeä, sillä se ilmaisee, että kyseinen tunnus tulkitaan globaalin muuttujan tunnukseksi. Ilman koodiriviä \verb+global g+ funktion määritelmän sisällä oleva muuttuja olisi paikallinen muuttuja, ja esimerkkiohjelma tulostaisi luvut 2 ja 1.

Pythonissa kaikki esitetään olioina. Lisäksi kaikki asiat, jotka voidaan nimetä, ovat ensimmäisen luokan arvoja -- myös funktiot, metodit ja moduulit \cite{pythonhistory}. 

\section{Kontrollin ohjaus}

Ohjelmointikielen tarjoamat rakenteet kontrollin ohjaukseen ovat hyvin tärkeitä kielen käytön kannalta. Monipuoliset kontrollinohjausrakenteet mahdollistavat erilaisten ongelmien ratkaisemisen selkeällä tavalla.

\subsection{Python}

Modernina kielenä Python sisältää tehokkaita keinoja ohjata laskentaa.

\subsubsection{Laskentajärjestys}
Pythonin operaattoreiden laskentajärjestys on 16-tasoinen \cite{pythonprecedence}. Ensimmäisenä laskentajärjestyksessä huomioidaan esimerkiksi listojen ja hajautustaulujen alkioiden erottimet. Viimeisenä lasketaan lambda-lausekkeet, joilla Pythonissa ilmaistaan anonyymeja funktioita. Aritmeettiset operaatiot ja bittioperaatiot lasketaan samassa järjestyksessä kuin C-pohjaisissa kielissä. Laskentajärjestyksen tasojen runsaan määrän vuoksi operaatioiden laskentajärjestyksen ilmaisemiseen kannattaa yleensä käyttää sulkuja. 

\subsubsection{Valinta ja toisto}
Pythonissa käytetään valintaan ehtolauseita \verb+if+, \verb+elif+ ja \verb+else+. Ehtolauseita käytettäessä ehto tulkitaan epätodeksi, jos ehdon arvo on \verb+False+, \verb+None+ (olio, jota käytetään ilmaisemaan arvon puuttumista), minkä hyvänsä tyyppinen numeerinen arvo nolla tai tyhjä merkkijono tai tietorakenne (kuten lista tai hajautustaulu) \cite{pythoncompound}. Muussa tapauksessa ehto tulkitaan todeksi, ellei oliota ole erikseen määritelty tulkittavaksi epätodeksi.

Toistoon voidaan käyttää \verb+for+-toistolausetta, ehdollista \verb+while+-lausetta tai rekursiota. Käytettäessä \verb+while+-lausetta ehto tulkitaan samalla tavalla kuin ehtolauseiden yhteydessä. Muutoin \verb+while+ toimii samalla periaatteella kuin Javassa. Monessa muussa kielessä esiintyvää \verb+do-while+-toistorakennetta Pythonissa ei ole.

Pythonin \verb+for+-lause muistuttaa Javan \verb+for-each+-silmukkaa, ja sillä voidaan iteroida iteroitavia olioita, kuten listoja, merkkijonoja ja iteraattoreita \cite{pythoncompound}. Iteraattori on olio, jolla on metodi \verb+next()+, joka palauttaa seuraavan alkion. Iteraattori voi käydä läpi esimerkiksi listan alkioita tai luonnollisten lukujen joukkoa.

Seuraava esimerkkiohjelma tulostaa parittomat luvut väliltä [1, 10[:
\begin{samepage}
\begin{verbatim}
for luku in range(1, 10):
    if (luku % 2 != 0):
    	    print luku
\end{verbatim}
\end{samepage}

Ohjelmassa käytetään Pythonin (version 2) funktiota \verb+range+, joka tässä esimerkissä palauttaa järjestetyn listan kaikista kokonaisluvuista funktion argumentteina annettujen kahden luvun välillä. Lista käydään läpi \verb+for+-silmukassa, ja jokaisen parittoman luvun kohdalla kyseinen luku tulostetaan.

Pythonin erikoisuutena \verb+while+- ja \verb+for+-lauseiden yhteydessä voidaan käyttää \verb+else+-lausetta \cite{pythoncompound}. Jos \verb+while+-silmukan lopussa on \verb+else+, \verb+else+-haaran koodi suoritetaan, kun \verb+while+:n ehto on epätosi ja silmukka päättyy. Jos \verb+for+-lauseen lopussa on \verb+else+, \verb+else+-haara suoritetaan, kun iteroitavan olion kaikki alkiot on käyty läpi. Kummassakaan tapauksessa \verb+else+-haaran koodia ei suoriteta, jos silmukka päättyy \verb+break+- tai \verb+continue+-komentoon. Pythonin \verb+break+ ja \verb+continue+ toimivat samalla tavalla kuin Javan vastaavat komennot.

Pythonissa toisto voidaan toteuttaa myös käyttämällä rekursiota. Python ei kuitenkaan tue häntärekursion eliminointia \cite{pythontre}, minkä vuoksi häntärekursiota hyödyntäviä funktioita ei voida toteuttaa tehokkaasti.

\subsection{COBOL}

COBOLissa on Pythonia yksinkertaisempi kontrollin ohjaus. Vanhana kielenä se ei alunperin sisältänyt nykyaikaisissa kielissä lähes itsestään selviä ominaisuuksia kuten rekursiota.

\subsubsection{Laskentajärjestys}

COBOLin aritmeettisten lausekkeiden evaluoinnin järjestys riippuu COBOLin versiosta ja kääntäjän toteuttajasta. Compaqin COBOLissa laskentajärjestyksessä on neljä tasoa \cite{compaqcobol}. Ensimmäisenä määritetään muuttujien etumerkit. Tämän jälkeen potenssit, jonka jälkeen kerto- ja jakolaskut. Viimeisenä suoritetaan yhteen- ja vähennyslaskut.

COBOLin viimeisimmissä versioissa kieleen tulivat mukaan myös bittioperaatiot. Micro Focus'n Visual COBOL -toteutuksessa tämä on nostanut laskentatasoja seitsemään \cite{visualcobol}. Bittioperaatioista \verb+NOT+ evaluoidaan yhdessä etumerkkien kanssa. Muuten bittioperaatiot evaluoidaan viimeisinä järjestyksessä \verb+AND+, \verb+XOR+ ja \verb+OR+. 

\subsubsection{Valinta}

Valinta suoritetaan rakenteella \verb+IF - THEN - ELSE - ENDIF+ \cite{cobolintro}.

\begin{verbatim}
* Yksinkertainen valinta
    IF NUMERO = 2
      DISPLAY 'KAKSI'
    END-IF
    
* IF ELSE -lause
    IF NUMERO IS EQUAL TO 2 THEN
        DISPLAY 'KAKSI'
    ELSE
        DISPLAY 'EI KAKSI'
    END-IF
    
* sisäkkäinen IF ELSE -lause
    IF NUMERO = 1
        DISPLAY 'NUMERO'
    ELSE
        IF NUMERO = 2
            DISPLAY 'KAKSI'
        ELSE
            DISPLAY 'EI YKSI EIKÄ KAKSI'
        END-IF
    END-IF
\end{verbatim}

Esimerkistä huomataan, että rakenne vastaa pitkälti Javan If-valintalausetta. Avainsana \verb+THEN+ on vapaaehtoinen \cite{easytrieve}, mutta mahdollistaa luonnollisen englanninkielen kaltaisen lausemuodon. If-rakenne lopetetaan avainsanalla \verb+END-IF+, joka on mahdollista korvata myös pisteellä. COBOL ei kuitenkaan tue monen modernin kielen käyttämää else-if -valintaa. Else-if on korvattava esimerkin kaltaisilla sisäkkäisillä if-else -valintalauseilla.

COBOLin vastaavuus Javan tai C:n switch-case -rakenteelle on \verb+EVALUATE+-verbi \cite{cobolintro}.

\begin{samepage}
\begin{verbatim}
EVALUATE VALIKKO-SYOTE
    WHEN "0"
        DISPLAY 'VALITSIT 0'
    WHEN "1" THRU "9"
        DISPLAY 'VALITSIT 1-9'
END-EVALUATE.
\end{verbatim}
\end{samepage}

Esimerkissä EVALUATE -verbiä seuraa evaluaation subjekti, \verb+VALIKKO-SYOTE+. Avainsana \verb+WHEN+ vastaa pitkälti switch-case -rakenteen \verb+case+a. Evaluaation lopettaa avainsana \verb+END-EVALUATE+. Esimerkissä jos \verb+VALIKKO-SYOTE+ on 0, näytetään käyttäjälle "VALITSIT 0". Jos se on yhden ja yhdeksän väliltä, näytetään "VALITSIT 1-9". Toisin kuin Javan switch-case, EVALUATE tukee useita samanaikaisia vertailuja - muuttujia ja ehtoja voi ketjuttaa avainsanan \verb+ALSO+ avulla.

\subsubsection{Toisto}

COBOL tukee pitkälti samoja toistorakenteita kuin Java. Tässä lueteltavat toistorakenteet esittelee Cobol Tutorial \cite{cobolintro2}. COBOLin vastaavuus while-rakenteelle ja do-while-rakenteelle on \verb+PERFORM UNTIL+, jossa toistoehdon voi sijoittaa alkuun tai loppuun.

Javan for-toistorakennetta vastaa \verb+PERFORM - TIMES+ ja \verb+PERFORM VARYING+. Seuraava esimerkki tulostaa käyttäjälle viisi kertaa sanan "HEI":

\begin{samepage}
\begin{verbatim}
PERFORM 5 TIMES
    DISPLAY "HEI"
END-PERFORM
\end{verbatim}
\end{samepage}

\verb+PERFORM VARYING+ mahdollistaa Javan tapaisen for-toistorakenteen, jossa muuttujan arvoa korotetaan yhden kierroksen jälkeen muulla kuin yhdellä.

\begin{samepage}
\begin{verbatim}
PERFORM VARYING NUMERO FROM 1 BY 2 
    UNTIL NUMERO > 5
	DISPLAY 'Numero on nyt: ' NUMERO
END-PERFORM
\end{verbatim}
\end{samepage}

Esimerkissä muuttujaa NUMERO korotetaan jokaisen kierroksen jälkeen kahdella. Esimerkin tulostus:

\begin{samepage}
\begin{verbatim}
Numero on nyt: 1
Numero on nyt: 3
Numero on nyt: 5
\end{verbatim}
\end{samepage}


\subsubsection{Rekursio}

Alunperin COBOL ei mahdollistanut rekursiota lainkaan \cite{wikipediacobol}. Uudemmista COBOLin versioista ainakin IBM:n COBOL-toteutus tukee rekursiota. IBM:n toteutuksessa rekursiivisesti kutsuttavan ohjelman tai aliohjelman Program-ID:ssä on annettava ehto \verb+RECURSIVE+ \cite{enterprisecobol}. Mikäli ohjelmaa kutsuu rekursiivisesti ilman rekursiosta eksplisiittisesti kertovaa \verb+RECURSIVE+-ehtoa, ohjelman suoritus päättyy.

\section{Etuja ja haittoja}
Pythonissa kaikki arvot ovat ensimmäisen luokan arvoja, ja funktiot ensimmäisen luokan arvoina mahdollistavat kielen käyttämisen myös funktionaaliseen ohjelmointiin. Häntärekursion optimoinnin puuttuminen tosin rajoittaa tehokasta funktionaalista ohjelmointia.

COBOLin valintalauseiden haittana on else if -avainsanan puuttuminen, jolloin haaroittuvan valinnan voi joutua rakentamaan useilla sisäkkäisille if-else -valinnoilla. Toisaalta kielelle ominainen \verb+EVALUATE+ helpottaa useiden ehtojen yhtäaikaista vertailua.

Rekursion ja laskentatasojen vähäisyys voi vaikeuttaa koodillisesti siistien algoritmien ohjelmoimista. COBOLin pääkäyttökohteena on kuitenkin yritysmaailman ohjelmistot, joissa rekursiolle on tarvetta vähemmän kuin tieteellisen laskennan piirissä.


\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}


\end{document}
