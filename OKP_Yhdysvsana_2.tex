\documentclass{tktltiki}

\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{comment}

\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{Otsikko}
\author{Erkki Heino \and Tero Huomo \and Eeva Terkki}
\date{\today}

\maketitle


\mytableofcontents

\section{N‰kyvyysalueet}

\subsection{COBOL}

\subsection{Python}

Pythonin lohkorakenne on syv‰, ja ohjelman suoritusaikana k‰ytˆss‰ on ainakin kolme sis‰kk‰ist‰ n‰kyvyysaluetta \cite{pythonclasses}. N‰kyvyysalueita k‰ytet‰‰n dynaamisesti. Sisimm‰ll‰ n‰kyvyysalueella ovat paikalliset nimet. Mahdollisilla funktioita ymp‰rˆivill‰ funktioilla on omat n‰kyvyysalueensa, joiden sis‰lt‰m‰t nimet eiv‰t ole paikallisia eiv‰tk‰ globaaleja. Toisiksi uloimmalla n‰kyvyysalueella ovat moduulin globaalit nimet ja kaikkein uloimmalla kieleen rakennetut nimet. 

Pythonissa luokan n‰kyvyysalueella m‰‰ritellyt nimet eiv‰t n‰y luokan metodeille \cite{pythonexec}. Metodin ensimm‰inen argumentti, jolle on tapana antaa nimi \verb+self+, edustaa luokan ilmentym‰‰. Sen kautta metodi voi k‰ytt‰‰ luokan ilmentym‰n muita metodeja ja attribuutteja.

Seuraavassa esimerkiss‰ on kaksi sis‰kk‰ist‰ funktiota:

% voisi varmaan nimet‰ fiksummin
\begin{samepage}
\begin{verbatim}
def f1():
    a = 	1	
    def f2():
        b = 2
        print a + b            
    print a
    f2()
    
f1()
\end{verbatim}
\end{samepage}

Funktio \verb+f1+ m‰‰rittelee muuttujan \verb+a+ ja funktion \verb+f2+, tulostaa \verb+a+:n arvon ja kutsuu m‰‰rittelem‰‰ns‰ funktiota. Funktio \verb+f2+ m‰‰rittelee muuttujan \verb+b+ ja tulostaa muuttujien \verb+a+ ja \verb+b+ arvojen summan. Ohjelma tulostaa luvut 1 ja 3. Muuttuja \verb+a+ on n‰kyviss‰ funktion \verb+f1+ ja sen sis‰isten funktioiden sis‰ll‰. Muuttuja \verb+b+ puolestaan on paikallinen muuttuja, joka on n‰kyviss‰ vain \verb+f2+-funktion sis‰ll‰. Siihen viittaaminen \verb+f2+-funktion ulkopuolella johtaisi virhetilanteeseen.

Seuraavassa esimerkiss‰ k‰ytet‰‰n globaalia muuttujaa:

% n‰m‰kin voisi nimet‰ fiksummin
\begin{samepage}
\begin{verbatim}
g = 1

def f3():
    global g
    g = 2
    print g
    
f3()
print g
\end{verbatim}
\end{samepage}

Esimerkiss‰ globaalin muuttujan \verb+g+ arvoksi alustetaan ensin luku 1. Funktio \verb+f3+ asettaa \verb+g+:n arvoksi luvun 2 ja myˆs tulostaa muuttujan arvon. Kun funktiota \verb+f3+ kutsutaan ja sen j‰lkeen viel‰ tulostetaan \verb+g+:n arvo, ohjelma tulostaa kaksi kertaa luvun 2. Funktio \verb+f3+ siis k‰sittelee globaalia muuttujaa. Avainsana \verb+global+ on t‰rke‰, sill‰ se ilmaisee, ett‰ kyseinen tunnus tulkitaan globaalin muuttujan tunnukseksi. Ilman koodirivi‰ \verb+global g+ funktion m‰‰ritelm‰n sis‰ll‰ oleva muuttuja olisi paikallinen muuttuja, ja esimerkkiohjelma tulostaisi luvut 2 ja 1.

Pythonissa kaikki asiat, jotka voidaan nimet‰, ovat ensimm‰isen luokan arvoja -- myˆs funktiot, metodit ja moduulit \cite{pythonhistory}. 


\section{Sidonta}

\subsection{Cobol}

\subsection{Python}


\section{Kontrollin ohjaus}

\subsection{Python}

\subsubsection{Valinta}

\subsubsection{Toisto}

\subsubsection{Rekursio}

\subsection{COBOL}

\subsubsection{Aritmeettisten operaatioiden laskentaj‰rjestys}

COBOLin aritmeettisten lausekkeiden evaluoinnin j‰rjestys riippuu COBOLin versiosta ja k‰‰nt‰j‰n toteuttajasta. Compaqin COBOLissa laskentaj‰rjestyksess‰ on nelj‰ tasoa \cite{compaqcobol}. Ensimm‰isen‰ m‰‰ritet‰‰n muuttujien etumerkit. T‰m‰n j‰lkeen potenssit, jonka j‰lkeen kerto- ja jakolaskut. Viimeisen‰ suoritetaan yhteen- ja v‰hennyslaskut.

COBOLin viimeisimmiss‰ versioissa kieleen tuli mukaan myˆs bittioperaatiot. Micro Focus'n Visual COBOL toteutuksess‰ t‰m‰ on nostanut laskentatasoja seitsem‰‰n \cite{visualcobol}. Bittioperaatioista \verb+NOT+ evaluoidaan yhdess‰ etumerkkien kanssa. Muuten bittioperaatiot evaluoidaan viimeisin‰ j‰rjestyksess‰ \verb+AND+, \verb+XOR+ ja \verb+OR+. 

\subsubsection{Valinta}

Valinta suoritetaan rakenteella \verb+IF - THEN - ELSE - ENDIF+ \cite{}.

\begin{samepage}
\begin{verbatim}
* Yksinkertainen valinta
    IF NUMERO = 2
      DISPLAY 'KAKSI'
    END-IF
    
* IF ELSE -lause
    IF NUMERO IS EQUAL TO 2 THEN
        DISPLAY 'KAKSI'
    ELSE
        DISPLAY 'EI KAKSI'
    END-IF
    
* sis‰kk‰inen IF ELSE -lause
    IF NUMERO = 1
        DISPLAY 'NUMERO'
    ELSE
        IF NUMERO = 2
            DISPLAY 'KAKSI'
        ELSE
            DISPLAY 'EI YKSI EIKƒ KAKSI'
        END-IF
    END-IF
\end{verbatim}
\end{samepage}


Esimerkist‰ huomataan, ett‰ rakenne vastaa pitk‰lti Javan If-valintalausetta. Avainsana \verb+THEN+ on vapaaehtoinen \cite{easytrieve}, mutta mahdollistaa luonnollisen englanninkielen kaltaisen lausemuodon. If-rakenne lopetetaan avainsanalla \verb+END-IF+, joka on mahdollista korvata myˆs pisteell‰. COBOL ei kuitenkaan tue monen modernin kielen k‰ytt‰m‰‰ else-if -valintaa. Else-if on korvattava esimerkin kaltaisilla sis‰kk‰isill‰ if-else -valintalauseilla.

COBOLin vastaavuus Javan tai C:n Switch-case -rakenteelle on \verb+EVALUATE+ -verbi \cite{cobolintro}.

\begin{samepage}
\begin{verbatim}
EVALUATE VALIKKO-SYOTE
    WHEN "0"
        DISPLAY 'VALITSIT 0'
    WHEN "1" THRU "9"
        DISPLAY 'VALITSIT 1-9'
END-EVALUATE.
\end{verbatim}
\end{samepage}

Esimerkiss‰ EVALUATE -verbi‰ seuraa evaluaation subjekti, \verb+VALIKKO-SYOTE+. Avainsana \verb+WHEN+ vastaa pitk‰lti Switch-case -rakenteen \verb+case+a. Evaluaation lopettaa avainsana \verb+END-EVALUATE+. Esimerkiss‰ jos \verb+VALIKKO-SYOTE+ on 0, n‰ytet‰‰n k‰ytt‰j‰lle "VALITSIT 0". Jos se on yhden ja yhdeks‰n v‰lilt‰, n‰ytet‰‰n "VALITSIT 1-9". Toisin kuin Javan Switch-Case, EVALUATE tukee useita samanaikaisia vertailuja - muuttujia ja ehtoja voi ketjuttaa avainsanan \verb+ALSO+ avulla.


\subsubsection{Toisto}

COBOL tukee pitk‰lti samoja toistorakenteita kuin Java. T‰ss‰ lueteltavat toistorakenteet esittelee Cobol Tutorial \cite{cobolintro2}. COBOLin vastaavuudet while-rakenteelle ja do-while -rakenteelle on \verb+PERFORM UNTIL+, jossa toistoehdon voi sijoittaa alkuun tai loppuun.

Javan For-looppia vastaa \verb+PERFORM - TIMES+ ja \verb+PERFORM VARYING+. Seuraava esimerkki tulostaa k‰ytt‰j‰lle viisi kertaa sanan "HEI":

\begin{samepage}
\begin{verbatim}
PERFORM 5 TIMES
    DISPLAY "HEI"
END-PERFORM
\end{verbatim}
\end{samepage}

\verb+PERFORM VARYING+ mahdollistaa Javan tapaisen for-loopin, jossa muuttujan arvoa korotetaan yhden kierroksen j‰lkeen muulla kuin yhdell‰.

\begin{samepage}
\begin{verbatim}
PERFORM VARYING NUMERO FROM 1 BY 2 
    UNTIL NUMERO > 5
	DISPLAY 'Numero on nyt: ' NUMERO
END-PERFORM
\end{verbatim}
\end{samepage}

Esimerkiss‰ muuttujaa NUMERO korotetaan jokaisen kierroksen j‰lkeen kahdella. Esimerkin tulostus:

\begin{samepage}
\begin{verbatim}
Numero on nyt: 1
Numero on nyt: 3
Numero on nyt: 5
\end{verbatim}
\end{samepage}


\subsubsection{Rekursio}

Alunperin COBOL ei mahdollistanut rekursiota lainkaan \cite{wikipediacobol}. Uudemmista COBOLin versioista ainakin IBM:n COBOL-toteutus tukee rekursiota. IBM:n toteutuksessa rekursiivisesti kutsuttavan ohjelman tai aliohjelman Program-ID:ss‰ on annettava ehto \verb+RECURSIVE+ \cite{enterprisecobol}. Mik‰li ohjelmaa kutsuu rekursiivisesti ilman rekursiosta eksplisiittisesti kertovaa \verb+RECURSIVE+-ehtoa, ohjelman suoritus p‰‰ttyy. 


\newpage
 
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}


\end{document}
